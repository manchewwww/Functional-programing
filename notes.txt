###################################################################################################
# Week_01 - Numbers. Recursion (part 1)
###################################################################################################

[X] Assume the day and time will not change.
[X] Because 03.03 is a holiday we'll move the next session to 01.03 (Wednesday), room 500, 17:00.
   - The room does not have computers.
[X] Make a chat in Facebook with the name FP_IS_22-23.
[X] Introduce ^_^ Mihi ^_^ !
[X] Introduce ForHome.
   - will add Mihi to our email thread when giving feedback for week 1;
      - ❗SEND EMAIL WITH "Reply ALL" option❗
[X] Introduce GitHub repository.
[X] File > Autosave.

- VEEERY whitespace sensitive, i.e. tabs, spaces, new lines matter (a lot)
- comments:
   - use -- for single line comments
   - use {--} for multiline comments
   - only for human-readable text!
- everything is a function here!
   - read the following: a = 5 (a :: Int)
   - a++, ++a <- invalid. Use (a + 1)
- use camel case to name identifiers, i.e. myFunction
- #include ... (C++) -> import ... (Haskell)
- when passing negative numbers as parameters surround them in brackets
   - example: helper (-1)


Types
 ❗Important: 1. All types start with a capital letter!
              2. All types must be known at compile time! (strongly typed language; not the dynamic programming principles)
              3. If f returns Int, then f cannot return Double! (statically typed language)

 - Bool     -> True False

 - Int      -> whole numbers;          uses 32 bits                (ex. 1, 10, 153)
 - Integer  -> whole numbers;          unbounded                   (ex. 123456789123456789123456798)

 - Float    -> floating-point numbers; equivalent to float in C++  (ex. 1.52)
 - Double   -> floating-point numbers; equivalent to double in C++ (ex. 1.5252525252525252525252525252)
 - Rational -> floating-point numbers; unbounded

 - Char     -> equivalent to char                        in C++ (ex. 'a', '1', 'C', '\n')
 - String   -> equivalent to std::string and const char* in C++ (ex. "Haskell")


Built-in Functions
 - boolean logical operators: && || not

 - arithmetic:  +, -, * (Only for variables of the same type, i.e. n * m will give an error if n is Int and m - Double)
 
 - division:
    - for whole numbers:
        - quotient: div (ex. div 10 5 == 2; div 123 10 == 12)
        - remainder: mod (ex. mod 10 5 == 0; mod 123 10 == 3) (equivalent to % in C++)
    - real numbers:
        - use only "/" (equivalent to "/" in C++, but here it cannot be used for whole numbers)
 
 - power:
    - use n ^ m  when m is a natural number (i.e. m > 0) (ex. 2 ^ 3 == 8)
    - use n ** m when m is a floating-point number (ex. 2 ** 0.5 == 1.4142135623730951)
 
 - other: min, max, odd, even, gcd, abs, sqrt (sqrt 2 == 1.4142135623730951; sqrt :: Double -> Double)

 - ❗❗❗ Int -> Double: fromIntegral           (ex. if a is 5, then (fromIntegral a) is 5.0 ) ❗❗❗
 - ❗❗❗ Double -> Int: ceiling, floor, round, truncate  (ex. round 5.45 == 5)                          ❗❗❗
 - ❗❗❗      != (C++) => /= (Haskell)         (ex. 5 /= 5 == False; True /= False == True)   ❗❗❗


 - The "Hello world" function:

    ($) - read this function as "after"; accepts a function as a left parameter and an expression as a right side.
    First it evaluates the expression.
    Then it passes the result to the function.

        print             $       "Hello world"
          ^               ^              ^
         / \             / \            / \
        /   \           /   \          /   \
          |               |              |
          |               |              |
          |               |              |
          |               |              |
       identifier      identifier       a string
       of a function   of a function


What is a predicate?
   Function that returns True or False.


Conditions:
   if ... then ... else ...
   guards. Often denoted by the pipe symbol (|). The equivalent of a switch case in C++.
      ❗Prefer guards to if-then-else statements ❗


Types of Evaluation Processes

   Linearly Recursive:
      1. The result is stored in a recursive tail.

      2. The recursive call is part of an expression.

   Linearly Iterative:
      1. The result is stored as a variable that is set by ANOTHER function.
      Often the variable is named "result" and the function - "helper".
      
      2. The recursive call is not part of an expression.
      These processes are faster than the linearly recursive ones!



###################################################################################################
# Week_02 - Recursion (part 2)
###################################################################################################

FOR HOME:
   WARNING:
      Getting a "Yes" does not mean getting a bonus!


What is a declaration and what is a definition?
   int add(const int x, const int y)       <-- ???
   {                                       <-- ???
      return x + y;                       <-- ???
   }                                       <-- ???


Closure
   ???


Type Inference - The Declaration Can Be Skipped
   The The Glasgow Haskell Compiler (GHC) can "guess" (more technically "infer") the types of every function
     - this ability is called type inference
   fname :: [type1 -> type2 -> ... ->]returnType     <= This is not needed

###################################################################################################
# Week_05 - Lambda Expressions. Tuples
###################################################################################################

Lambda Expressions
   - functions without a name (anonymous)
      - have to be called or passed as an argument immediately
      - called "arrow functions" in JS, TS, Frontend Frameworks
      - in Python: lambda x: x + 1
      - in C++: https://www.youtube.com/watch?v=mWgmBBz0y8c
      - Why use lambda functions? https://stackoverflow.com/questions/3259322/why-use-lambda-functionscha
      - ChatGPT:
            Lambda functions, also known as anonymous functions, are a type of function in programming that can be defined without a name and can be used in place of a named function in many situations. Here are some reasons why you might want to use lambda functions:

            1. Conciseness: Lambda functions are a way to write short, concise pieces of code that can be easily understood.
            2. Flexibility: Lambda functions are very flexible and can be used in a variety of different situations, such as sorting and filtering data.
            3. Function passing: Lambda functions can be passed as arguments to other functions, making it easier to write higher-order functions.
            4. Improved performance: Using lambda functions can improve performance in certain situations, such as when working with large datasets or when using functional programming techniques.
            5. Readability: Lambda functions can make code more readable by reducing the number of named functions needed and allowing for more inline code.

            Overall, lambda functions are a powerful tool that can make code more efficient, flexible, and readable.

   - have three parts: brackets, "the slash" \, "the arrow" ->
      - (\ <parameters> -> <function application>)

   - a lambda that adds 5 to a number:
   (\ x -> x + 5)

   - a lambda-predicate that checks whether a number is greater than 10:
   (\ x -> x > 10)

   - a lambda which adds three numbers:
   (\ x y z -> x + y + z)

   - What is an unary function?
      Functions that accept 1 argument.
   - What is a binary function?
      Functions that accept 2 arguments.
   - Can you give examples?
      unary : reverse, even, fromIntegral
      binary: mod, div, +, -
   
   - Remember: The evaluation happens from LEFT TO RIGHT.

Function Composition
   Composition of f and g over x: f $ g x -- f (g x)
                                    (f . g) x

Tuples (Vectors) (Ordered pairs)

   - data structures whose size has to be explicitly stated (analogy with array in C++)
   - can hold multiple types (ex. x :: (Int, String, [Double]) is a vector with 3 dimenstions)

   - fst (5, 6) => 5
   - snd (5, 6) => 6

   Examples:
   a vector with two coordinates representing a point in 2D space:
   type Point2D = (Int, Int) -- typedef std::pair<int, int> Point2D;

   Now every function that accepts a Point2D will look like this:

   helper :: Point2D -> Int -- instead of (Int, Int) -> Int. Our new version has more meaning.
   helper (x, y) = x + y -- this function sums up the coordinates. Notice the pattern matching!
   -- helper x = fst x + snd x -- only for 2D vectors

   Recap:
      type String = [Char]

Typeclasses

   We can say that a function should accept numbers in general, not only Int or Double.

   Example:

   old:
      helper :: Int -> Int

   new:
      helper :: (Num a, Num b) => a -> b
